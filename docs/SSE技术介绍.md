# SSE技术介绍文档（更新版）

## 1. SSE基本概念

Server-Sent Events（服务器发送事件，简称SSE）是一种基于HTTP协议的服务器推送技术，允许服务器向客户端推送数据。与传统的HTTP请求-响应模式不同，SSE建立了一个长连接，服务器可以通过这个连接持续地向客户端发送消息，而无需客户端重复发起请求。这种单向通信机制特别适合于实时通知、数据更新等场景。

SSE的工作原理相对简单。客户端通过JavaScript的EventSource API发起一个特殊的HTTP请求，服务器保持这个连接打开，并通过这个连接以特定格式发送事件数据。每当有新数据可用时，服务器就会将其推送给客户端，客户端通过事件监听器接收并处理这些数据。

SSE使用的是标准的HTTP协议，这意味着它能够很好地与现有的Web基础设施（如代理服务器、负载均衡器等）配合工作。同时，由于其基于文本的简单协议格式，SSE的实现和调试也相对容易。

在HTTP层面，SSE连接使用的是普通的GET请求，但服务器响应的Content-Type被设置为"text/event-stream"，这告诉浏览器应该将响应内容解析为事件流。服务器发送的数据需要遵循特定的格式，通常每条消息以"data:"前缀开头，以两个换行符结束。

## 2. SSE与WebSocket对比

在讨论实时Web通信技术时，SSE和WebSocket是两种常见的选择。虽然它们都能实现服务器向客户端推送数据的功能，但在设计理念、功能特性和适用场景上存在显著差异。

WebSocket提供了全双工通信能力，允许客户端和服务器之间进行双向实时通信。它建立在TCP协议之上，使用自定义的协议，需要特殊的服务器支持。WebSocket连接一旦建立，就可以在同一个连接上双向传输数据，这使得它特别适合需要频繁双向通信的应用，如在线游戏、协作编辑工具或聊天应用。

相比之下，SSE是单向通信机制，只允许服务器向客户端推送数据，不支持客户端向服务器发送消息（客户端需要通过常规的HTTP请求发送数据）。SSE基于标准的HTTP协议，这意味着它能够更好地与现有的Web基础设施兼容，如代理服务器、防火墙等。此外，SSE还内置了自动重连机制，当连接断开时，浏览器会自动尝试重新建立连接。

从性能角度看，WebSocket在建立连接时需要进行握手过程，但一旦连接建立，其传输效率较高，适合频繁的小数据包交换。SSE则使用HTTP长连接，初始连接建立较快，但每条消息都包含HTTP头部，在高频通信场景下可能效率较低。

在浏览器兼容性方面，现代浏览器普遍支持WebSocket和SSE，但SSE在IE浏览器中不被原生支持（需要使用polyfill）。另一方面，由于SSE基于HTTP，它能更好地处理代理和防火墙环境，而WebSocket在某些网络环境中可能会被阻止。

选择SSE还是WebSocket，主要取决于应用的具体需求。如果只需要服务器向客户端推送数据（如新闻更新、股票价格、通知等），SSE是一个更简单、更轻量的选择。如果需要双向实时通信，特别是客户端需要频繁向服务器发送数据的场景，WebSocket可能是更合适的选择。

在我们的订单通知系统中，由于主要需求是服务器在收到上游系统订单回调后通知前端，这是一个典型的单向数据推送场景，因此SSE是一个理想的技术选择。

## 3. 项目中的SSE实现说明

在我们的项目中，我们使用SpringBoot 2.7.5作为后端框架，React作为前端框架，实现了一个基于SSE的订单实时通知系统。下面将详细介绍后端和前端的实现细节。

### 3.1 后端实现

在SpringBoot后端，我们主要通过以下几个组件实现了SSE功能：

首先，我们创建了一个`OrderEvent`模型类，用于封装订单事件数据。这个类包含订单ID、状态、金额、时间戳和消息等字段，用于在服务器和客户端之间传递订单信息。

核心的SSE实现在`ISseEmitterService`服务类中。这个类负责管理所有客户端的SSE连接，并提供了以下主要功能：

1. 使用`ConcurrentHashMap`存储所有的SSE连接，确保线程安全
2. `createEmitter`方法用于创建新的SSE连接，设置1小时的超时时间
3. `sendToClient`方法用于向指定客户端发送事件
4. `broadcastToAll`方法用于向所有客户端广播事件
5. `sendHeartbeat`方法实现心跳机制，保持连接活跃

对于每个连接，我们通过`registerCallbacks`方法设置了完成、超时和错误处理回调，以便在连接状态变化时进行适当的资源清理。同时，实现了`removeSseEmitter`方法，确保在创建新连接前清理可能存在的旧连接。

`OrderCallbackService`服务类负责处理从上游系统接收到的订单回调，并通过`ISseEmitterService`将订单事件推送给前端。这个类使用`@Async`注解确保消息发送不会阻塞主业务流程。

在`SseController`控制器类中，我们提供了以下RESTful API端点：
1. `/api/sse/connect` - 建立SSE连接，支持可选的clientId参数
2. `/api/order/callback` - 接收订单回调
3. `/api/order/simulate` - 模拟订单回调
4. `/api/sse/status` - 获取SSE连接状态

所有API端点都通过`@CrossOrigin`注解支持跨域请求，但在生产环境中应该限制为特定域名。

2. 前端实现部分的更新：
```markdown:docs%2FSSE%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md
### 3.2 前端实现

在React前端，我们创建了一个`OrderNotification`组件，实现了完整的SSE客户端功能：

1. 状态管理：
   - `orderEvents` - 存储接收到的订单事件
   - `connected` - 跟踪SSE连接状态
   - `loading` - 控制加载状态显示
   - `lastHeartbeat` - 记录最后一次心跳时间
   - `reconnectTimer` - 管理重连定时器
   - `sseRef` - 使用useRef保存EventSource实例

2. 事件监听处理：
   - `CONNECT` - 处理连接建立事件
   - `HEARTBEAT` - 处理心跳消息，更新最后心跳时间
   - `ORDER_UPDATE` - 处理订单更新事件，解析数据并更新UI
   - `error` - 处理连接错误，支持自动重连

3. 核心功能实现：
   - `connectSSE` - 建立SSE连接，自动处理重连逻辑
   - `disconnectSSE` - 安全地关闭SSE连接
   - `simulateOrderCallback` - 触发模拟订单回调测试
   - `getStatusColor` - 根据订单状态返回对应的标签颜色
   - `formatTimestamp` - 格式化时间戳显示

4. 心跳检测机制：
   使用`useEffect`实现心跳检测，当超过45秒没有收到心跳时自动重新连接。检测间隔为10秒，确保连接的可靠性。

5. UI实现：
   使用Ant Design组件库创建了一个功能完整的界面：
   - 显示连接状态和最后心跳时间
   - 提供连接/断开连接按钮
   - 支持模拟订单回调测试
   - 使用List组件展示订单更新历史
   - 通过Tag组件用不同颜色标识订单状态
   - 支持空状态显示

所有的状态更新和事件处理都经过优化，确保了组件的性能和可靠性。错误处理和状态管理都经过完善，提供了良好的用户体验。
